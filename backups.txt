#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
BIOPEP UWM Selenium Automation Script
Automatyzuje proces analizy peptydÃ³w na stronie BIOPEP UWM
"""

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException, WebDriverException
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
import os
import time
from datetime import datetime

DEFAULT_TIMEOUT = 1000  # w sekundach

class BIOPEPAnalyzer:
    def __init__(self, headless=False, timeout=DEFAULT_TIMEOUT):
        self.driver = None
        self.wait = None
        self.results = []
        self.headless = headless
        self.timeout = timeout
        self.base_folder = "/home/marta/Desktop/biobloom_proteomic_data/accurate_proteomes"

    def setup_driver(self):
        try:
            print("ğŸ”§ Inicjalizacja drivera przeglÄ…darki...")
            options = webdriver.ChromeOptions()
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.add_argument('--disable-gpu')
            options.add_argument('--user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
            if self.headless:
                options.add_argument('--headless=new')
                print("ğŸ”§ Uruchamianie w trybie headless")
            else:
                print("ğŸ”§ Uruchamianie z interfejsem graficznym")
            service = Service(ChromeDriverManager().install())
            self.driver = webdriver.Chrome(service=service, options=options)
            self.driver.set_page_load_timeout(self.timeout + 60)
            self.wait = WebDriverWait(self.driver, self.timeout)
            print("âœ“ Driver przeglÄ…darki zostaÅ‚ pomyÅ›lnie zainicjalizowany")
        except WebDriverException as e:
            print(f"âŒ BÅ‚Ä…d podczas inicjalizacji przeglÄ…darki: {e}")
            raise

    def get_file_path(self):
        while True:
            filename = input("Podaj nazwÄ™ pliku FASTA (bez rozszerzenia): ").strip()
            if not filename:
                print("âŒ Nazwa pliku nie moÅ¼e byÄ‡ pusta!")
                continue
            full_path = os.path.join(self.base_folder, f"{filename}.fasta")
            if os.path.exists(full_path):
                print(f"âœ“ Znaleziono plik: {full_path}")
                return full_path
            else:
                print(f"âŒ Plik {full_path} nie istnieje!")
                retry = input("Czy chcesz sprÃ³bowaÄ‡ ponownie? (t/n): ").lower()
                if retry != 't':
                    return None

    def navigate_to_biopep(self):
        url = "https://biochemia.uwm.edu.pl/biopep/batch_processing.php?but_processing.x=61&but_processing.y=16"
        try:
            print(f"ğŸŒ Nawigacja do: {url}")
            self.driver.get(url)
            self.wait.until(EC.presence_of_element_located((By.TAG_NAME, "body")))
            print("âœ“ Strona BIOPEP zostaÅ‚a zaÅ‚adowana")
        except TimeoutException:
            print("âŒ Timeout podczas Å‚adowania strony BIOPEP")
            raise

    def read_fasta_file(self, file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            print(f"âœ“ Przeczytano plik FASTA: {os.path.basename(file_path)} ({len(content)} znakÃ³w)")
            return content
        except Exception as e:
            print(f"âŒ BÅ‚Ä…d podczas czytania pliku FASTA: {e}")
            raise

    def configure_analysis_settings(self, file_path):
        try:
            print("âš™ï¸ Konfigurowanie ustawieÅ„ analizy...")
            fasta_content = self.read_fasta_file(file_path)

            # Odznacz niepotrzebne checkboxy
            checkboxes_to_uncheck = ["profiles", "profilemarker", "calculationsatas", "profileepi"]
            for checkbox_value in checkboxes_to_uncheck:
                try:
                    checkbox = self.driver.find_element(By.CSS_SELECTOR, f"input[name='wybor[]'][value='{checkbox_value}']")
                    if checkbox.is_selected():
                        checkbox.click()
                        print(f"âœ“ OdklikniÄ™to: {checkbox_value}")
                except NoSuchElementException:
                    pass

            # Zaznacz wymagane checkboxy
            required_checkboxes = ["calculationsab", "enzymesaction", "searchfragments", "calculationsdvb"]
            for option in required_checkboxes:
                try:
                    checkbox = self.driver.find_element(By.CSS_SELECTOR, f"input[name='wybor[]'][value='{option}']")
                    if not checkbox.is_selected():
                        checkbox.click()
                    print(f"âœ“ Zaznaczono opcjÄ™: {option}")
                except NoSuchElementException:
                    pass

            # AktywnoÅ›Ä‡
            try:
                activity_select = Select(self.driver.find_element(By.NAME, "sel_activity"))
                activity_select.select_by_value("ACE inhibitor")
                print("âœ“ Wybrano aktywnoÅ›Ä‡: ACE inhibitor")
            except NoSuchElementException:
                pass

            # Wprowadzanie sekwencji
            try:
                textarea = self.wait.until(EC.presence_of_element_located((By.NAME, "txt_seq")))
                self.driver.execute_script("arguments[0].value = arguments[1];", textarea, fasta_content)
                print(f"âœ“ Wprowadzono sekwencje do textarea ({len(fasta_content)} znakÃ³w)")
            except TimeoutException:
                print("âŒ Nie znaleziono pola textarea dla sekwencji")
                raise

            # Enzymy
            enzyme_settings = {"enz1": "13", "enz2": "12", "enz3": "11"}
            enzyme_names = {"enz1": "pepsin (pH 1.3)", "enz2": "trypsin", "enz3": "chymotrypsin (A)"}
            for enz_name, enz_value in enzyme_settings.items():
                try:
                    enzyme_select = Select(self.driver.find_element(By.NAME, enz_name))
                    enzyme_select.select_by_value(enz_value)
                    print(f"âœ“ Wybrano {enz_name}: {enzyme_names[enz_name]} (wartoÅ›Ä‡: {enz_value})")
                except NoSuchElementException:
                    pass

            # Baza danych
            try:
                database_select = self.driver.find_element(By.NAME, "sel_database")
                database_sel = Select(database_select)
                database_sel.select_by_value("pep")
                print("âœ“ Wybrano bazÄ™ danych: pep")
            except NoSuchElementException:
                pass

            print("âœ… Konfiguracja ustawieÅ„ zakoÅ„czona pomyÅ›lnie")
        except Exception as e:
            print(f"âŒ BÅ‚Ä…d podczas konfigurowania ustawieÅ„: {e}")
            raise

    def start_analysis(self):
        try:
            print("ğŸš€ Uruchamianie analizy...")
            report_button = self.wait.until(
                EC.element_to_be_clickable((By.NAME, "but_report"))
            )
            report_button.click()
            print("âœ“ KlikniÄ™to przycisk uruchamiajÄ…cy analizÄ™")
            print("â³ Oczekiwanie na wyniki analizy...")

            # Czekamy aÅ¼ pojawi siÄ™ formularz wynikowy
            self.wait.until(
                EC.presence_of_element_located(
                    (By.CSS_SELECTOR, 'form[name="fm_action"][action="batch_report_cutting_for_seq"] table.table-out')
                )
            )

            print("âœ“ Formularz wynikowy zostaÅ‚ zaÅ‚adowany")

        except TimeoutException:
            print("âŒ Timeout podczas oczekiwania na wyniki")
            raise

    def extract_sequences(self):
        try:
            print("ğŸ” Analizowanie wynikÃ³w...")
            tables = self.driver.find_elements(By.CSS_SELECTOR, "form[name='fm_action'] table.table-out")
            if not tables:
                print("âŒ Nie znaleziono tabeli z wynikami")
                return
            print(f"âœ“ Znaleziono {len(tables)} tabel do analizy")

            # Filtrowanie tylko tych tabel, ktÃ³re zawierajÄ… sÅ‚owo "Sequence"
            filtered_tables = [table for table in tables if "Sequence" in table.text]
            print(f"âœ“ Do dalszej analizy wybrano {len(filtered_tables)} tabel z 'Sequence'")

            for table in filtered_tables:
                rows = table.find_elements(By.TAG_NAME, "tr")[1:]  # pomijamy nagÅ‚Ã³wek
                for row in rows:
                    cells = row.find_elements(By.TAG_NAME, "td")
                    if len(cells) >= 5:
                        sequence = cells[1].text.strip()
                        activity = cells[2].text.strip()
                        if "ACE inhibitor" in activity and sequence and sequence not in self.results:
                            self.results.append(sequence)
                            print(f"âœ“ Znaleziono sekwencjÄ™: {sequence}")
        except Exception as e:
            print(f"âŒ BÅ‚Ä…d podczas wyodrÄ™bniania sekwencji: {e}")
            raise


    def save_results(self):
        try:
            if not self.results:
                print("âš ï¸ Brak wynikÃ³w do zapisania")
                return
            timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
            file_path = os.path.join(self.base_folder, f"biopep_results_{timestamp}.txt")
            with open(file_path, 'w', encoding='utf-8') as f:
                for seq in self.results:
                    f.write(seq + "\n")
            print(f"ğŸ’¾ Wyniki zapisano w pliku: {file_path}")
        except Exception as e:
            print(f"âŒ BÅ‚Ä…d podczas zapisywania wynikÃ³w: {e}")

    def close_driver(self):
        if self.driver:
            self.driver.quit()
            print("ğŸšª ZamkniÄ™to przeglÄ…darkÄ™")


def main():
    analyzer = BIOPEPAnalyzer(headless=False)
    analyzer.setup_driver()
    try:
        file_path = analyzer.get_file_path()
        if not file_path:
            print("âŒ Nie podano pliku. KoÅ„czenie programu.")
            return
        analyzer.navigate_to_biopep()
        analyzer.configure_analysis_settings(file_path)
        analyzer.start_analysis()
        analyzer.extract_sequences()
        analyzer.save_results()
    finally:
        analyzer.close_driver()


if __name__ == "__main__":
    main()
